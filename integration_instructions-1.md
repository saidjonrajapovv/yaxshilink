
## WebSocket протокол

### Endpoint

```
wss://api.yaxshi.link/ws/fandomats
```

### Формат сообщений

Все сообщения отправляются в формате **JSON**:

```json
{
  "type": "MESSAGE_TYPE",
  "field1": "value1",
  "field2": "value2"
}
```

---

## Процесс подключения

### 1. Установка WebSocket соединения

```python
import websockets

websocket = await websockets.connect("wss://api.yaxshi.link/ws/fandomats")
```

### 2. Аутентификация (HELLO)

Сразу после подключения отправьте сообщение HELLO:

```json
{
  "type": "HELLO",
  "fandomat_id": 3,
  "device_token": "fnd_a7b3c9d2e8f4g1h5i6j7k8l9m0n1",
  "version": "1.0.0"
}
```

**Параметры:**
- `type` - тип сообщения (всегда "HELLO")
- `fandomat_id` - ID фандомата (число)
- `device_token` - токен устройства (можно получить в админке) 
- `version` - версия прошивки фандомата (опционально)

### 3. Ответ сервера

**Успех:**
```json
{
  "type": "OK",
  "message": "Фандомат 3 успешно подключен"
}
```

**Ошибка:**
```json
{
  "type": "ERROR",
  "error": "Неверный device_token"
}
```

### 4. Heartbeat (PING/PONG)

Сервер периодически (каждые 30 секунд) отправляет PING:

**Сервер → Фандомат:**
```json
{
  "type": "PING"
}
```

**Фандомат → Сервер:**
```json
{
  "type": "PONG"
}
```

⚠️ **Важно:** Отвечайте на PING в течение 10 секунд, иначе соединение будет разорвано!

---


### 1. Начало сессии (START_SESSION)

Когда пользователь сканирует QR-код фандомата, сервер отправляет команду:

**Сервер → Фандомат:**
```json
{
  "type": "START_SESSION",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": 42,
  "fandomat_id": 3
}
```

**Фандомат должен:**
1. Сохранить `session_id`
2. Открыть приемник для бутылок
3. Показать пользователю "Готов к приему"
4. Отправить подтверждение SESSION_STARTED

**Фандомат → Сервер:**
```json
{
  "type": "SESSION_STARTED",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Ответ сервера:**
```json
{
  "type": "OK",
  "message": "Сессия начата"
}
```

### 2. Прием бутылок (BOTTLE_ACCEPTED)

При каждом приеме бутылки отправьте:

**Фандомат → Сервер:**
```json
{
  "type": "BOTTLE_ACCEPTED",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "code": "BTL-003-00001",
  "material": "plastic",
  "timestamp": "2025-10-06T15:30:45.123Z"
}
```

**Параметры:**
- `session_id` - ID активной сессии
- `code` - уникальный код бутылки (рекомендуется формат: `BTL-{fandomat_id:03d}-{counter:05d}`)
- `material` - тип материала: `"plastic"` или `"aluminum"`
- `timestamp` - время приема в формате ISO 8601 UTC

**Ответ сервера:**
```json
{
  "type": "OK",
  "message": "Бутылка принята"
}
```

### 2.1. Проверка бутылки (CHECK_BOTTLE)

⚠️ **Рекомендуется:** Перед приемом бутылки проверяйте её SKU в базе данных

Когда фандомат определил SKU бутылки (например, через штрих-код или камеру), отправьте запрос на проверку:

**Фандомат → Сервер:**
```json
{
  "type": "CHECK_BOTTLE",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "sku": "123321"
}
```

**Параметры:**
- `session_id` - ID активной сессии
- `sku` - SKU (артикул) бутылки для проверки

**Ответ сервера (бутылка найдена):**
```json
{
  "type": "BOTTLE_CHECK_RESULT",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "exist": true,
  "bottle": {
    "id": 1,
    "name": "Coca-Cola 0.5L",
    "size": 0.5,
    "material": "plastic",
    "sku": "12344334",
    "image": "/images/bottles/abc123.jpg"
  }
}
```

**Ответ сервера (бутылка НЕ найдена):**
```json
{
  "type": "BOTTLE_CHECK_RESULT",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "exist": false
}
```

**Рекомендуемый процесс приема:**
1. Пользователь помещает бутылку в фандомат
2. Фандомат определяет SKU (штрих-код/камера/NFC)
3. Отправляется `CHECK_BOTTLE` с SKU
4. Если `exist: true` - отправить `BOTTLE_ACCEPTED` с данными из `bottle`
5. Если `exist: false` - отклонить бутылку (SKU не зарегистрирован)

**Пример использования:**
```python
# Получили SKU бутылки
sku = "COCA-500-PL"

# Проверяем бутылку
await send_message({
    "type": "CHECK_BOTTLE",
    "session_id": current_session_id,
    "sku": sku
})

# Получаем ответ
response = await receive_message()

if response["exist"]:
    bottle = response["bottle"]
    # Бутылка зарегистрирована - принимаем
    await send_message({
        "type": "BOTTLE_ACCEPTED",
        "session_id": current_session_id,
        "code": generate_code(),
        "material": bottle["material"],
        "timestamp": datetime.utcnow().isoformat() + "Z"
    })
else:
    # Бутылка не зарегистрирована - отклоняем
    show_error("Этот тип бутылки не принимается")
```

### 3. Завершение сессии (SESSION_END)

Сессия завершается в одном из случаев:

#### A. Автоматическое завершение (90 сек неактивности)

Если в течение 90 секунд не было принято ни одной бутылки, фандомат отправляет:

**Фандомат → Сервер:**
```json
{
  "type": "SESSION_END",
  "session_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Ответ:**
```json
{
  "type": "OK",
  "message": "Сессия завершена. Принято бутылок: 5"
}
```

#### B. Отмена сессии сервером (CANCEL_SESSION)

Если пользователь завершает сессию через приложение:

**Сервер → Фандомат:**
```json
{
  "type": "CANCEL_SESSION",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "reason": "Завершено пользователем через фронтенд"
}
```

**Фандомат должен:**
1. Закрыть приемник
3. Показать пользователю "Спасибо!"

---

## Протокол сообщений

### От фандомата к серверу

| Тип сообщения | Когда отправляется | Обязательные поля |
|---------------|-------------------|-------------------|
| `HELLO` | При подключении | `fandomat_id`, `device_token` |
| `PONG` | В ответ на PING | - |
| `SESSION_STARTED` | Подтверждение начала сессии | `session_id` |
| `CHECK_BOTTLE` | Проверка бутылки по SKU | `session_id`, `sku` |
| `BOTTLE_ACCEPTED` | При приеме бутылки | `session_id`, `code`, `material` |
| `SESSION_END` | Завершение сессии | `session_id` |

### От сервера к фандомату

| Тип сообщения | Когда отправляется | Обязательные поля |
|---------------|-------------------|-------------------|
| `OK` | Успешная обработка | `message` |
| `ERROR` | Ошибка | `error` |
| `PING` | Каждые 30 секунд | - |
| `START_SESSION` | Пользователь сканировал QR | `session_id`, `user_id` |
| `CANCEL_SESSION` | Отмена сессии | `session_id`, `reason` |
| `BOTTLE_CHECK_RESULT` | Результат проверки бутылки | `session_id`, `exist` |

---


## Обработка ошибок

### Типичные ошибки и решения

| Ошибка | Причина | Решение |
|--------|---------|---------|
| `Не аутентифицирован` | HELLO не отправлен или отклонен | Отправьте HELLO с правильными credentials |
| `Сессия не найдена` | Неверный session_id | Проверьте, что используете актуальный session_id |
| `Сессия не активна` | Сессия уже завершена | Дождитесь новой START_SESSION команды |
| `Неверный формат session_id` | session_id не UUID | Используйте session_id из START_SESSION |
| `session_id и sku обязательны` | Не указан SKU в CHECK_BOTTLE | Укажите оба параметра: session_id и sku |
| `WebSocket closed` | Соединение разорвано | Переподключитесь и отправьте HELLO заново |

---

## Чек-лист интеграции

### Обязательная функциональность

- [ ] Подключение к WebSocket
- [ ] Отправка HELLO и аутентификация
- [ ] Ответ на PING сообщения (PONG)
- [ ] Обработка START_SESSION
- [ ] Отправка SESSION_STARTED
- [ ] Проверка бутылки через CHECK_BOTTLE (рекомендуется)
- [ ] Отправка BOTTLE_ACCEPTED при приеме бутылки
- [ ] Отправка SESSION_END при завершении
- [ ] Обработка CANCEL_SESSION
- [ ] Переподключение при разрыве соединения

### Рекомендуемая функциональность

- [ ] Таймер автозакрытия (90 секунд)
- [ ] Уникальные коды для каждой бутылки
- [ ] Валидация бутылок по SKU перед приемом
- [ ] Логирование всех операций
- [ ] Обработка ошибок
- [ ] Индикация статуса подключения
- [ ] Отображение информации о сессии пользователю

---
